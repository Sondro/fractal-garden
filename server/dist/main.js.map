{"version":3,"sources":["../mandelbulb.glsl","../pass-through-vert.glsl","../upsample.glsl","../renderer.js","../headless.js","main.js"],"names":["module","exports","setupRenderer","frag","regl","repeat","offsets","width","height","sdfTexture","texture","Math","round","sdfFBO","framebuffer","color","getSDFFBO","getScreenFBO","textureOptions","tex1","tex2","one","two","counter","createPingPongBuffers","position","buffer","renderSDF","vert","passThroughVert","replace","uniforms","screenSize","prop","cameraPosition","cameraDirection","offset","scrollX","scrollY","attributes","count","drawToCanvas","inputTexture","upSample","upSampleFrag","inputSample","previous","generateRenderSteps","renderState","fbo","use","currentScreenBuffer","performUpSample","previousScreenBuffer","newSampleFBO","newScreenBuffer","sample","setup","context","preserveDrawingBuffer","renderer","reglContext","renderFrame","state","clear","depth","steps","step","next","done","value","console","log","read","renderFrames","frames","fps","first","timespan","length","time","ceil","frame","app","express","json","limit","port","headless","transformFrames","map","Object","values","get","req","res","send","post","body","dir","mkdirSync","i","data","Buffer","from","listen"],"mappings":"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","file":"main.js","sourceRoot":"..","sourcesContent":["module.exports=\"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 screenSize;\\nuniform vec2 offset;\\nuniform vec2 repeat;\\nuniform float time;\\nuniform vec3 cameraPosition;\\nuniform mat4 cameraDirection;\\nuniform bool onlyDistance;\\nuniform float scrollX;\\nuniform float scrollY;\\n\\nconst float hitThreshold = 0.00015;\\nconst int MAX_ITER = 200;\\n\\nconst vec3 spaceRepetition = vec3(3.5);\\n\\nvec3 getRay() {\\n    vec2 normalizedCoords = gl_FragCoord.xy - vec2(0.5) + (offset / repeat);\\n    vec2 pixel = (normalizedCoords - 0.5 * screenSize) / min(screenSize.x, screenSize.y);\\n\\n    // as if the higher the pixel value, the more the offset is being applied\\n    // normalize to get unit vector\\n    return (cameraDirection * normalize(vec4(pixel.x, pixel.y, 1, 0))).xyz;\\n}\\n\\nvec3 opRepeat(vec3 p, vec3 distance) {\\n    return mod(p + 0.5 * distance, distance) - 0.5 * distance;\\n}\\n\\nfloat doModel(vec3 p) {\\n    vec3 pos = opRepeat(p, spaceRepetition);\\n\\tvec3 z = pos;\\n\\tfloat dr = 1.0;\\n\\tfloat r = 0.0;\\n\\tfor (int i = 0; i < 10; i++) {\\n\\t\\tr = length(z);\\n\\t\\tif (r > 4.) break;\\n\\t\\t\\n\\t\\t// convert to polar coordinates\\n\\t\\tfloat theta = acos(z.z / r);\\n\\t\\tfloat phi = atan(z.y, z.x);\\n        float power = 12. + sin(scrollY) * 10.;\\n\\t\\tdr =  pow(r, power - 1.) * power * dr + 1.5;\\n\\t\\t\\n\\t\\t// scale and rotate the point\\n\\t\\tfloat zr = pow(r, power);\\n\\t\\ttheta = theta * power;\\n\\t\\tphi = phi * power;\\n\\t\\t\\n\\t\\t// convert back to cartesian coordinates\\n\\t\\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\\n\\t\\tz += pos;\\n\\t}\\n\\treturn abs(0.5 * log(r) * r / dr);\\n}\\n// this is kinda contrived and does a bunch of stuff I'm not using right now, but I'll leave it like this for now\\nvec3 trace(vec3 origin, vec3 direction, out int iterations) {\\n    vec3 position = origin;\\n    float distanceTraveled = 0.;\\n    mat3 scrollXRotate = mat3(\\n        1,  sin(scrollX) * 0.05, 0,\\n        -sin(scrollX) * 0.05, 1, 0,\\n        0,             0,            1\\n    );\\n    for(int i = 0; i < MAX_ITER; i++) {\\n        iterations = i;\\n        float d = doModel(position);\\n        if (d < hitThreshold * distanceTraveled) break;\\n        position += d * direction;\\n        direction = scrollXRotate * direction;\\n        distanceTraveled += d;\\n    }\\n    return position;\\n}\\n\\nfloat getIllumination(vec3 collision, int iterations) {\\n    float occlusionLight = 1. - float(iterations) / float(MAX_ITER);\\n    return occlusionLight;\\n}\\n\\n// const float col = 0.05; // amount of coloring\\n\\nvec3 hsl2rgb( in vec3 c ) {\\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\\n}\\n\\nvec3 getColor(float it, float d) {\\n    return hsl2rgb(vec3(\\n        d,\\n        0.5,\\n        1. - pow(it, 0.8)\\n    ));\\n}\\n\\nvoid main() {\\n    vec3 direction = getRay();\\n    // gl_FragColor = vec4(offset / (repeat - vec2(1)), 0, 1);\\n    // return;\\n\\n    // gl_FragColor = vec4(opRepeat(cameraPosition, vec3(2.5)), 1);\\n    // return;\\n\\n    int iterations;\\n    vec3 collision = trace(cameraPosition, direction, iterations);\\n    gl_FragColor = vec4(\\n        getColor(float(iterations) / float(MAX_ITER), distance(collision, spaceRepetition / 2.)),\\n        1.\\n    );\\n    // gl_FragColor = vec4(1., 0, 0, 1);\\n    // return;\\n}\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 uv;\\nvoid main() {\\n    uv = position;\\n    gl_Position = vec4(position, 0, 1);\\n}\";","module.exports=\"precision highp float;\\nprecision mediump sampler2D;\\n#define GLSLIFY 1\\nuniform sampler2D inputSample;\\nuniform sampler2D previous;\\nuniform vec2 offset;\\nuniform vec2 repeat;\\nuniform vec2 screenSize;\\n\\nconst vec2 pixelOffset = vec2(0.499);\\n\\nvec2 modulo (vec2 a, vec2 b) {\\n    vec2 d = floor(a / b);\\n    vec2 q = d * b;\\n    return a - q;\\n}\\n\\nfloat getMixFactor (vec2 position) {\\n    vec2 rest = modulo(position, repeat);\\n    vec2 diff = abs(rest - (offset));\\n    return 1. - min(max(diff.x, diff.y), 1.);\\n}\\n\\nvoid main () {\\n    vec2 position = gl_FragCoord.xy - pixelOffset;\\n    vec2 pixel = position / screenSize;\\n\\n    vec4 previousColor = texture2D(previous, pixel);\\n    vec4 newColor = texture2D(inputSample, pixel);\\n\\n    gl_FragColor = mix(previousColor, newColor, getMixFactor(position));\\n}\\n\\n// 1, 3 position\\n// 1, 0 offset\\n// 3, 3 repeat\\n\\n// 1, 0 rest\\n// 0, 0 diff\\n// 0 mix factor\\n\\n// 1 - 3 * floor(1/3) = 0 -> want it to be 2\\n// 3 - 3\\n\\n// 0, 3 = 0 -> 0 - 3 * floor (0 / 3) = 0\\n// 1, 3 = 1 -> 1 - 3 * floor (1 / 3) = 1;\\n// 2, 3 = 2 -> 2 - 3 * floor (2 / 3) = 2\\n// 3, 3 = 0 -> 3 - 3 * floor (3 / 3) = 0\\n// 4, 3 = 1 -> 4 - 3 * floor (4 / 3) = 1\\n// 5, 3 = 2\\n// 6, 3 = 0\\n// 7, 3 = 1\\n\\n// 1, 3 -> 1, 0\\n\\n// 2, 3 position\\n// 2, 0 offset\\n// 3, 3 repeat\\n\\n// restX = mod(2, 3) = 2 - 3 * floor(2 / 3) = 2\\n// restY = mod(3, 3) = 3 - 3 * floor(3 / 3) = 0\\n// 2, 0 rest\\n// diff = (2, 0) - (2, 0) = (0, 0)\\n// 1 - min(max(0,0), 1) = 0\";","import passThroughVert from './pass-through-vert.glsl';\nimport upSampleFrag from './upsample.glsl';\n\nfunction setupRenderer({\n    frag,\n    regl,\n    repeat = [1, 1],\n    offsets = [],\n    width,\n    height,\n}) {\n    // The FBO the actual SDF samples are rendered into\n    let sdfTexture = regl.texture({\n        width: Math.round(width / repeat[0]),\n        height: Math.round(height / repeat[1])\n    });\n    const sdfFBO = regl.framebuffer({ color: sdfTexture });\n    const getSDFFBO = () => sdfFBO({ color: sdfTexture });\n    \n    // We need a double buffer in order to progressively add samples for each render step\n    const createPingPongBuffers = textureOptions => {\n        const tex1 = regl.texture(textureOptions);\n        const tex2 = regl.texture(textureOptions);\n        const one = regl.framebuffer({\n          color: tex1\n        });\n        const two = regl.framebuffer({\n          color: tex2\n        });\n        let counter = 0;\n        return () => {\n            counter++;\n            if (counter % 2 === 0) {\n                return one({ color: tex1 });\n            }\n            return two({ color: tex2 });\n        }\n    };\n    \n    let getScreenFBO = createPingPongBuffers({\n        width,\n        height,\n    });\n    \n    // screen-filling rectangle\n    const position = regl.buffer([\n        [-1, -1],\n        [1, -1],\n        [1,  1],\n        [-1, -1],   \n        [1, 1,],\n        [-1, 1]\n    ]);\n    \n    const renderSDF = regl({\n        frag,\n        vert: passThroughVert.replace(\"#define GLSLIFY 1\", \"\"),\n        uniforms: {\n            screenSize: regl.prop('screenSize'),\n            cameraPosition: regl.prop('cameraPosition'),\n            cameraDirection: regl.prop('cameraDirection'),\n            offset: regl.prop('offset'),\n            repeat: regl.prop('repeat'),\n            scrollX: regl.prop('scrollX'),\n            scrollY: regl.prop('scrollY'),\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    // render texture to screen\n    const drawToCanvas = regl({\n        vert: passThroughVert.replace(\"#define GLSLIFY 1\\n\", \"\"),\n        frag: `\n            precision highp float;\n            uniform sampler2D inputTexture;\n            varying vec2 uv;\n    \n            void main () {\n              vec4 color = texture2D(inputTexture, uv * 0.5 + 0.5);\n            //   vec4 color = vec4(uv.x, uv.y, 0, 1);\n              gl_FragColor = color;\n            }\n        `,\n        uniforms: {\n            inputTexture: regl.prop('texture'),\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    const upSample = regl({\n        vert: passThroughVert.replace(\"#define GLSLIFY 1\\n\", \"\"),\n        frag: upSampleFrag.replace(\"#define GLSLIFY 1\\n\", \"\"),\n        uniforms: {\n            inputSample: regl.prop('sample'), // sampler2D\n            previous: regl.prop('previous'), // sampler2D\n            repeat: regl.prop('repeat'), // vec2\n            offset: regl.prop('offset'), // vec2\n            screenSize: regl.prop('screenSize'), // vec2\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    // This generates each of the render steps, to be used in the main animation loop\n    // By pausing the execution of this function, we can let the main thread handle events, gc, etc. between steps\n    // It also allows us to bail early in case we ran out of time\n    function* generateRenderSteps(renderState){\n        const fbo = getSDFFBO();\n        fbo.use(() => {\n            renderSDF({\n                screenSize: [width / repeat[0], height / repeat[1]],\n                offset: [0,0],\n                repeat,\n                ...renderState\n            });\n            // console.log(\"hier moet het eigenlijk 255 zijn\", regl.read());\n        });\n        yield fbo;\n        \n        let currentScreenBuffer = getScreenFBO();\n        currentScreenBuffer.use(() => {\n            drawToCanvas({ texture: fbo });\n        });\n    \n        const performUpSample = (previousScreenBuffer, offset) => {\n            const newSampleFBO = getSDFFBO();\n            newSampleFBO.use(() => {\n                renderSDF({\n                    screenSize: [width / repeat[0], height / repeat[1]],\n                    offset,\n                    repeat,\n                    ...renderState\n                });\n            });\n    \n            const newScreenBuffer = getScreenFBO();\n            newScreenBuffer.use(() => {\n                upSample({\n                    sample: newSampleFBO,\n                    previous: previousScreenBuffer,\n                    repeat,\n                    offset,\n                    screenSize: [width, height],\n                });\n            });\n            return newScreenBuffer;\n        }\n    \n        for (let offset of offsets) {\n            currentScreenBuffer = performUpSample(currentScreenBuffer, offset);\n            yield currentScreenBuffer;\n        }\n        // also return the current screenbuffer so the last next() on the generator still gives a reference to what needs to be drawn\n        return currentScreenBuffer;\n    };\n\n    return {\n        regl,\n        drawToCanvas, // will draw fbo to canvas (or whatever was given as regl context)\n        generateRenderSteps, // generator that yields FBOs, that can be drawn to the canvas\n    }\n}\n\nexport default setupRenderer;\n","import Regl from \"regl\";\nimport frag from './mandelbulb.glsl';\nimport passThroughVert from './pass-through-vert.glsl';\nimport headlessGL from \"gl\";\nimport setupRenderer from \"./renderer\";\n\nconst setup = (width = 1000, height = 1000) => {\n    const repeat = [1, 1];\n    const offsets = [];\n    const context = headlessGL(width, height, { preserveDrawingBuffer: true });\n    const regl = Regl(context);\n\n    const renderer = setupRenderer({\n        frag: frag.replace(\"#define GLSLIFY 1\", \"\"),\n        reglContext: context,\n        repeat,\n        offsets,\n        width,\n        height,\n    });\n\n    const renderFrame = (state) => {\n        renderer.regl.clear({\n            depth: 1,\n        });\n        const steps = renderer.generateRenderSteps(state);\n        let step = steps.next();\n        while (!step.done) { // this shouldn't be necessary since we shouldn't be generating more than one render step\n            step = steps.next();\n        }\n        const fbo = step.value;\n        renderer.drawToCanvas({ texture: fbo });\n        console.log(renderer.regl.read());\n\n       return renderer.regl.read();\n    }\n\n    // screen-filling rectangle\n    const position = regl.buffer([\n        [-1, -1],\n        [1, -1],\n        [1,  1],\n        [-1, -1],   \n        [1, 1,],\n        [-1, 1]\n    ]);\n\n    const renderSDF = regl({\n        frag,\n        vert: passThroughVert.replace(\"#define GLSLIFY 1\", \"\"),\n        uniforms: {\n            screenSize: regl.prop('screenSize'),\n            cameraPosition: regl.prop('cameraPosition'),\n            cameraDirection: regl.prop('cameraDirection'),\n            offset: regl.prop('offset'),\n            repeat: regl.prop('repeat'),\n            scrollX: regl.prop('scrollX'),\n            scrollY: regl.prop('scrollY'),\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n\n    // const renderFrame = (state) => {\n    //     regl.clear({\n    //         depth: 1,\n    //     });\n\n    //     renderSDF({\n    //         ...state,\n    //         repeat,\n    //         offset: [0, 0],\n    //         screenSize: [width, height]\n    //     });\n    //     return regl.read();\n    // }\n\n    function* renderFrames(frames, fps = 60) {\n        const first = frames[0];\n        const last = frames[frames.length - 1];\n        const timespan = (last.time - first.time);\n        console.log(\"timespan:\", timespan)\n        const numFrames = Math.ceil(timespan / (1000 / fps));\n        for (let frame of frames) {\n            yield renderFrame(frame.state);\n        };\n    }\n\n    return { \n        renderFrame,\n        renderFrames,\n    };\n};\n\nexport default setup;\n","import headlessRenderer from '../headless.js';\nimport express from \"express\";\nimport cors from \"cors\";\nimport { writePngFile, writePngFileSync } from \"node-libpng\";\nimport fs from \"fs\";\nimport cuid from \"cuid\";\nconst app = express();\napp.use(cors());\napp.use(express.json({ limit: \"50mb\" }));\nconst port = 3000;\n\nconst width = 1920;\nconst height = 1080;\nconst headless = headlessRenderer(width, height);\n\nconst transformFrames = (frames) => {\n    return frames.map(frame => {\n        return {\n            ...frame,\n            state: {\n                ...frame.state,\n                cameraDirection: Object.values(frame.state.cameraDirection), // turn from object with string indices into array\n            }\n        }\n    })\n}\n\napp.get('/', (req, res) => {\n\n  res.send('Hello World!')\n});\n\napp.post('/render', async (req, res) => {\n    // console.log(req.body);\n    const frames = headless.renderFrames(transformFrames(req.body?.frames));\n    const dir = `./render-results/${cuid()}`;\n\n    console.log(\"going to render\", frames.length, \"frames\");\n\n    fs.mkdirSync(dir);\n    (function step(i = 0) {\n        let { value: frame, done } = frames.next();\n        if (done) return;\n        const data = Buffer.from(frame);\n        console.log(data);\n        writePngFileSync(`${dir}/frame-${i}.png`, data, {\n            width,\n            height,\n        });\n        step(i + 1);\n    })();\n\n    console.log(\"finished rendering images\");\n\n    res.send('Great success!');\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`)\n})"]}