{"version":3,"sources":["../mandelbulb.glsl","../pass-through-vert.glsl","../upsample.glsl","../renderer.js","../headless.js","main.js"],"names":["module","exports","setupRenderer","frag","reglContext","repeat","offsets","width","height","console","log","regl","sdfTexture","texture","Math","round","sdfFBO","framebuffer","color","getSDFFBO","getScreenFBO","textureOptions","tex1","tex2","one","two","counter","createPingPongBuffers","position","buffer","renderSDF","context","vert","passThroughVert","uniforms","screenSize","prop","cameraPosition","cameraDirection","offset","scrollX","scrollY","attributes","count","drawToCanvas","upSample","upSampleFrag","sample","previous","generateRenderSteps","renderState","fbo","use","currentScreenBuffer","performUpSample","previousScreenBuffer","newSampleFBO","newScreenBuffer","setup","container","preserveDrawingBuffer","renderer","fragmentShader","renderFrame","state","steps","step","next","done","value","read","headlessRenderer","app","bodyParser","json","port","get","req","res","send","post","body","listen"],"mappings":"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","file":"main.js","sourceRoot":"..","sourcesContent":["module.exports=\"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 screenSize;\\nuniform vec2 offset;\\nuniform vec2 repeat;\\nuniform float time;\\nuniform vec3 cameraPosition;\\nuniform mat4 cameraDirection;\\nuniform bool onlyDistance;\\nuniform float scrollX;\\nuniform float scrollY;\\n\\nconst float hitThreshold = 0.00015;\\nconst int MAX_ITER = 200;\\n\\nconst vec3 spaceRepetition = vec3(3.5);\\n\\nvec3 getRay() {\\n    vec2 normalizedCoords = gl_FragCoord.xy - vec2(0.5) + (offset / repeat);\\n    vec2 pixel = (normalizedCoords - 0.5 * screenSize) / min(screenSize.x, screenSize.y);\\n\\n    // as if the higher the pixel value, the more the offset is being applied\\n    // normalize to get unit vector\\n    return (cameraDirection * normalize(vec4(pixel.x, pixel.y, 1, 0))).xyz;\\n}\\n\\nvec3 opRepeat(vec3 p, vec3 distance) {\\n    return mod(p + 0.5 * distance, distance) - 0.5 * distance;\\n}\\n\\nfloat doModel(vec3 p) {\\n    vec3 pos = opRepeat(p, spaceRepetition);\\n\\tvec3 z = pos;\\n\\tfloat dr = 1.0;\\n\\tfloat r = 0.0;\\n\\tfor (int i = 0; i < 10; i++) {\\n\\t\\tr = length(z);\\n\\t\\tif (r > 4.) break;\\n\\t\\t\\n\\t\\t// convert to polar coordinates\\n\\t\\tfloat theta = acos(z.z / r);\\n\\t\\tfloat phi = atan(z.y, z.x);\\n        float power = 12. + sin(scrollY) * 10.;\\n\\t\\tdr =  pow(r, power - 1.) * power * dr + 1.5;\\n\\t\\t\\n\\t\\t// scale and rotate the point\\n\\t\\tfloat zr = pow(r, power);\\n\\t\\ttheta = theta * power;\\n\\t\\tphi = phi * power;\\n\\t\\t\\n\\t\\t// convert back to cartesian coordinates\\n\\t\\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\\n\\t\\tz += pos;\\n\\t}\\n\\treturn abs(0.5 * log(r) * r / dr);\\n}\\n// this is kinda contrived and does a bunch of stuff I'm not using right now, but I'll leave it like this for now\\nvec3 trace(vec3 origin, vec3 direction, out int iterations) {\\n    vec3 position = origin;\\n    float distanceTraveled = 0.;\\n    mat3 scrollXRotate = mat3(\\n        1,  sin(scrollX) * 0.05, 0,\\n        -sin(scrollX) * 0.05, 1, 0,\\n        0,             0,            1\\n    );\\n    for(int i = 0; i < MAX_ITER; i++) {\\n        iterations = i;\\n        float d = doModel(position);\\n        if (d < hitThreshold * distanceTraveled) break;\\n        position += d * direction;\\n        direction = scrollXRotate * direction;\\n        distanceTraveled += d;\\n    }\\n    return position;\\n}\\n\\nfloat getIllumination(vec3 collision, int iterations) {\\n    float occlusionLight = 1. - float(iterations) / float(MAX_ITER);\\n    return occlusionLight;\\n}\\n\\n// const float col = 0.05; // amount of coloring\\n\\nvec3 hsl2rgb( in vec3 c ) {\\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\\n}\\n\\nvec3 getColor(float it, float d) {\\n    return hsl2rgb(vec3(\\n        d,\\n        0.5,\\n        1. - pow(it, 0.8)\\n    ));\\n}\\n\\nvoid main() {\\n    vec3 direction = getRay();\\n    // gl_FragColor = vec4(offset / (repeat - vec2(1)), 0, 1);\\n    // return;\\n\\n    // gl_FragColor = vec4(opRepeat(cameraPosition, vec3(2.5)), 1);\\n    // return;\\n\\n    int iterations;\\n    vec3 collision = trace(cameraPosition, direction, iterations);\\n    gl_FragColor = vec4(\\n        getColor(float(iterations) / float(MAX_ITER), distance(collision, spaceRepetition / 2.)),\\n        1.\\n    );\\n}\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 uv;\\nvoid main() {\\n    uv = position;\\n    gl_Position = vec4(position, 0, 1);\\n}\";","module.exports=\"precision highp float;\\nprecision mediump sampler2D;\\n#define GLSLIFY 1\\nuniform sampler2D sample;\\nuniform sampler2D previous;\\nuniform vec2 offset;\\nuniform vec2 repeat;\\nuniform vec2 screenSize;\\n\\nconst vec2 pixelOffset = vec2(0.499);\\n\\nvec2 modulo (vec2 a, vec2 b) {\\n    vec2 d = floor(a / b);\\n    vec2 q = d * b;\\n    return a - q;\\n}\\n\\nfloat getMixFactor (vec2 position) {\\n    vec2 rest = modulo(position, repeat);\\n    vec2 diff = abs(rest - (offset));\\n    return 1. - min(max(diff.x, diff.y), 1.);\\n}\\n\\nvoid main () {\\n    vec2 position = gl_FragCoord.xy - pixelOffset;\\n    vec2 pixel = position / screenSize;\\n\\n    vec4 previousColor = texture2D(previous, pixel);\\n    vec4 newColor = texture2D(sample, pixel);\\n\\n    gl_FragColor = mix(previousColor, newColor, getMixFactor(position));\\n}\\n\\n// 1, 3 position\\n// 1, 0 offset\\n// 3, 3 repeat\\n\\n// 1, 0 rest\\n// 0, 0 diff\\n// 0 mix factor\\n\\n// 1 - 3 * floor(1/3) = 0 -> want it to be 2\\n// 3 - 3\\n\\n// 0, 3 = 0 -> 0 - 3 * floor (0 / 3) = 0\\n// 1, 3 = 1 -> 1 - 3 * floor (1 / 3) = 1;\\n// 2, 3 = 2 -> 2 - 3 * floor (2 / 3) = 2\\n// 3, 3 = 0 -> 3 - 3 * floor (3 / 3) = 0\\n// 4, 3 = 1 -> 4 - 3 * floor (4 / 3) = 1\\n// 5, 3 = 2\\n// 6, 3 = 0\\n// 7, 3 = 1\\n\\n// 1, 3 -> 1, 0\\n\\n// 2, 3 position\\n// 2, 0 offset\\n// 3, 3 repeat\\n\\n// restX = mod(2, 3) = 2 - 3 * floor(2 / 3) = 2\\n// restY = mod(3, 3) = 3 - 3 * floor(3 / 3) = 0\\n// 2, 0 rest\\n// diff = (2, 0) - (2, 0) = (0, 0)\\n// 1 - min(max(0,0), 1) = 0\";","import Regl from 'regl';\nimport passThroughVert from './pass-through-vert.glsl';\nimport upSampleFrag from './upsample.glsl';\n\nfunction setupRenderer({\n    frag,\n    reglContext,\n    repeat = [1, 1],\n    offsets = [],\n    width,\n    height,\n}) {\n    console.log(reglContext)\n    const regl = Regl(reglContext); // no params = full screen canvas\n    \n    // The FBO the actual SDF samples are rendered into\n    let sdfTexture = regl.texture({\n        width: Math.round(width / repeat[0]),\n        height: Math.round(height / repeat[1])\n    });\n    const sdfFBO = regl.framebuffer({ color: sdfTexture });\n    const getSDFFBO = () => sdfFBO({ color: sdfTexture });\n    \n    // We need a double buffer in order to progressively add samples for each render step\n    const createPingPongBuffers = textureOptions => {\n        const tex1 = regl.texture(textureOptions);\n        const tex2 = regl.texture(textureOptions);\n        const one = regl.framebuffer({\n          color: tex1\n        });\n        const two = regl.framebuffer({\n          color: tex2\n        });\n        let counter = 0;\n        return () => {\n            counter++;\n            if (counter % 2 === 0) {\n                return one({ color: tex1 });\n            }\n            return two({ color: tex2 });\n        }\n    };\n    \n    let getScreenFBO = createPingPongBuffers({\n        width,\n        height,\n    });\n    \n    // screen-filling rectangle\n    const position = regl.buffer([\n        [-1, -1],\n        [1, -1],\n        [1,  1],\n        [-1, -1],   \n        [1, 1,],\n        [-1, 1]\n    ]);\n    \n    const renderSDF = regl({\n        context: {\n        },\n        frag,\n        vert: passThroughVert,\n        uniforms: {\n            screenSize: regl.prop('screenSize'),\n            cameraPosition: regl.prop('cameraPosition'),\n            cameraDirection: regl.prop('cameraDirection'),\n            offset: regl.prop('offset'),\n            repeat: regl.prop('repeat'),\n            scrollX: regl.prop('scrollX'),\n            scrollY: regl.prop('scrollY'),\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    // render texture to screen\n    const drawToCanvas = regl({\n        vert: passThroughVert,\n        frag: `\n            precision highp float;\n            uniform sampler2D texture;\n            varying vec2 uv;\n    \n            void main () {\n              vec4 color = texture2D(texture, uv * 0.5 + 0.5);\n              gl_FragColor = color;\n            }\n        `,\n        uniforms: {\n            texture: regl.prop('texture'),\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    const upSample = regl({\n        vert: passThroughVert,\n        frag: upSampleFrag,\n        uniforms: {\n            sample: regl.prop('sample'), // sampler2D\n            previous: regl.prop('previous'), // sampler2D\n            repeat: regl.prop('repeat'), // vec2\n            offset: regl.prop('offset'), // vec2\n            screenSize: regl.prop('screenSize'), // vec2\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    // This generates each of the render steps, to be used in the main animation loop\n    // By pausing the execution of this function, we can let the main thread handle events, gc, etc. between steps\n    // It also allows us to bail early in case we ran out of time\n    function* generateRenderSteps(renderState){\n        const fbo = getSDFFBO();\n        fbo.use(() => {\n            renderSDF({\n                screenSize: [width / repeat[0], height / repeat[1]],\n                offset: [0,0],\n                repeat,\n                ...renderState\n            });\n        });\n    \n        yield fbo;\n        \n        // draw 1/4 res SDF FBO to full res FBO\n        let currentScreenBuffer = getScreenFBO();\n        currentScreenBuffer.use(() => {\n            drawToCanvas({ texture: fbo });\n        });\n    \n        const performUpSample = (previousScreenBuffer, offset) => {\n            const newSampleFBO = getSDFFBO();\n            newSampleFBO.use(() => {\n                renderSDF({\n                    screenSize: [width / repeat[0], height / repeat[1]],\n                    offset,\n                    repeat,\n                    ...renderState\n                });\n            });\n    \n            const newScreenBuffer = getScreenFBO();\n            newScreenBuffer.use(() => {\n                upSample({\n                    sample: newSampleFBO,\n                    previous: previousScreenBuffer,\n                    repeat,\n                    offset,\n                    screenSize: [width, height],\n                });\n            });\n            return newScreenBuffer;\n        }\n    \n        for (let offset of offsets) {\n            currentScreenBuffer = performUpSample(currentScreenBuffer, offset);\n            yield currentScreenBuffer;\n        }\n        // also return the current screenbuffer so the last next() on the generator still gives a reference to what needs to be drawn\n        return currentScreenBuffer;\n    };\n\n    return {\n        regl,\n        drawToCanvas, // will draw fbo to canvas (or whatever was given as regl context)\n        generateRenderSteps, // generator that yields FBOs, that can be drawn to the canvas\n    }\n}\n\nexport default setupRenderer;\n","import fragmentShader from './mandelbulb.glsl';\nimport setupRenderer from './renderer.js';\nimport headlessGL from \"headless-gl\";\n\nconst setup = (width = 1000, height = 1000) => {\n    const repeat = [1, 1];\n    const offsets = [];\n    const container = headlessGL(width, height, { preserveDrawingBuffer: true });\n\n    const renderer = setupRenderer({\n        frag: fragmentShader,\n        reglContext: container,\n        repeat,\n        offsets,\n        width,\n        height,\n    });\n\n    const renderFrame = (state) => {\n        const steps = renderer.generateRenderSteps(state);\n        let step = steps.next();\n        while (!step.done) { // this shouldn't be necessary sine we shouldn't be generating more than one render step\n            step = steps.next();\n        }\n        const fbo = step.value;\n        renderer.drawToCanvas({ texture: fbo });\n\n       return renderer.regl.read();\n    }\n\n    const renderFrames = (frames, fps = 60) => {\n        const first = frames[0];\n        const last = frames[frames.length - 1];\n        const timespan = last.time - first.time;\n        const numFrames = Math.ceil(timespan / (1000 / fps));\n\n        for (let i = 0; i < numFrames; i++) {\n            const time = i * (1000 / fps);\n            const startFrameIndex = frames.findIndex((frame) => frame.time - first.time >= time);\n            const startFrame = frames[startFrameIndex];\n            const endFrame = frames[startFrameIndex + 1] || startFrame;\n            const progress = (time - startFrame.time) / (endFrame.time - startFrame.time);\n            \n            // no interpolate all state\n\n        }\n    }\n\n    return renderFrame;\n};\n\nexport default setup;\n","import headlessRenderer from '../headless.js';\nimport express from \"express\";\nimport cors from \"cors\";\nimport bodyParser from \"body-parser\";\nconsole.log(\"hahaha\", headlessRenderer)\nconst app = express();\napp.use(cors());\napp.use(bodyParser.json());\nconst port = 3000;\napp.get('/', (req, res) => {\n\n  res.send('Hello World!')\n});\n\napp.post('/render', (req, res) => {\n    console.log(req.body);\n    res.send('Great success!');\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`)\n})"]}