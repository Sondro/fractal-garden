{"version":3,"sources":["../mandelbulb.glsl","../pass-through-vert.glsl","../upsample.glsl","../renderer.js","../headless.js","main.js"],"names":["module","exports","setupRenderer","frag","reglContext","repeat","offsets","width","height","regl","sdfTexture","texture","Math","round","getSDFFBO","framebuffer","color","getScreenFBO","textureOptions","tex1","tex2","one","two","counter","createPingPongBuffers","position","buffer","renderSDF","vert","passThroughVert","replace","uniforms","screenSize","prop","cameraPosition","cameraDirection","offset","scrollX","scrollY","attributes","count","drawToCanvas","inputTexture","upSample","upSampleFrag","inputSample","previous","generateRenderSteps","renderState","fbo","use","console","log","read","currentScreenBuffer","performUpSample","previousScreenBuffer","newSampleFBO","newScreenBuffer","sample","setup","container","preserveDrawingBuffer","renderer","fragmentShader","renderFrame","state","steps","step","next","done","value","renderFrames","frames","fps","first","timespan","length","time","numFrames","ceil","outputs","i","startFrameIndex","findIndex","frame","startFrame","push","app","bodyParser","json","port","headless","transformFrames","map","Object","values","get","req","res","send","post","body","data","Buffer","from","listen"],"mappings":";AAAAA,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;AC6KAC,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EA7Kf,IAAA,EAAA,EAAA,QAAA,SACA,EAAA,EAAA,QAAA,6BACA,EAAA,EAAA,QAAA,oBA2KeA,SAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,QAAAA,GAAAA,SAAAA,EAAAA,EAAAA,GAAAA,IAAAA,EAAAA,OAAAA,KAAAA,GAAAA,GAAAA,OAAAA,sBAAAA,CAAAA,IAAAA,EAAAA,OAAAA,sBAAAA,GAAAA,IAAAA,EAAAA,EAAAA,OAAAA,SAAAA,GAAAA,OAAAA,OAAAA,yBAAAA,EAAAA,GAAAA,cAAAA,EAAAA,KAAAA,MAAAA,EAAAA,GAAAA,OAAAA,EAAAA,SAAAA,EAAAA,GAAAA,IAAAA,IAAAA,EAAAA,EAAAA,EAAAA,UAAAA,OAAAA,IAAAA,CAAAA,IAAAA,EAAAA,MAAAA,UAAAA,GAAAA,UAAAA,GAAAA,GAAAA,EAAAA,EAAAA,EAAAA,OAAAA,IAAAA,GAAAA,QAAAA,SAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,MAAAA,OAAAA,0BAAAA,OAAAA,iBAAAA,EAAAA,OAAAA,0BAAAA,IAAAA,EAAAA,OAAAA,IAAAA,QAAAA,SAAAA,GAAAA,OAAAA,eAAAA,EAAAA,EAAAA,OAAAA,yBAAAA,EAAAA,MAAAA,OAAAA,EAAAA,SAAAA,EAAAA,EAAAA,EAAAA,GAAAA,OAAAA,KAAAA,EAAAA,OAAAA,eAAAA,EAAAA,EAAAA,CAAAA,MAAAA,EAAAA,YAAAA,EAAAA,cAAAA,EAAAA,UAAAA,IAAAA,EAAAA,GAAAA,EAAAA,EAzKf,SAASA,GAAc,KACnBC,EADmB,YAEnBC,EAFmB,OAGnBC,EAAS,CAAC,EAAG,GAHM,QAInBC,EAAU,GAJS,MAKnBC,EALmB,OAMnBC,IAEMC,MAAAA,GAAO,EAAKL,EAAAA,SAAAA,GAGdM,IAAAA,EAAaD,EAAKE,QAAQ,CAC1BJ,MAAOK,KAAKC,MAAMN,EAAQF,EAAO,IACjCG,OAAQI,KAAKC,MAAML,EAASH,EAAO,MAEjCS,MAAAA,EAAY,IAAML,EAAKM,YAAY,CAAEC,MAAON,IAsB9CO,IAAAA,EAnB0BC,CAAAA,IACpBC,MAAAA,EAAOV,EAAKE,QAAQO,GACpBE,EAAOX,EAAKE,QAAQO,GACpBG,EAAMZ,EAAKM,YAAY,CAC3BC,MAAOG,IAEHG,EAAMb,EAAKM,YAAY,CAC3BC,MAAOI,IAELG,IAAAA,EAAU,EACP,MAAA,MACHA,EACc,GAAM,EACTF,EAAI,CAAEL,MAAOG,IAEjBG,EAAI,CAAEN,MAAOI,KAITI,CAAsB,CACrCjB,MAAAA,EACAC,OAAAA,IAIEiB,MAAAA,EAAWhB,EAAKiB,OAAO,CACzB,EAAE,GAAI,GACN,CAAC,GAAI,GACL,CAAC,EAAI,GACL,EAAE,GAAI,GACN,CAAC,EAAG,GACJ,EAAE,EAAG,KAGHC,EAAYlB,EAAK,CACnBN,KAAAA,EACAyB,KAAMC,EAAgBC,QAAAA,QAAQ,oBAAqB,IACnDC,SAAU,CACNC,WAAYvB,EAAKwB,KAAK,cACtBC,eAAgBzB,EAAKwB,KAAK,kBAC1BE,gBAAiB1B,EAAKwB,KAAK,mBAC3BG,OAAQ3B,EAAKwB,KAAK,UAClB5B,OAAQI,EAAKwB,KAAK,UAClBI,QAAS5B,EAAKwB,KAAK,WACnBK,QAAS7B,EAAKwB,KAAK,YAEvBM,WAAY,CACRd,SAAAA,GAEJe,MAAO,IAILC,EAAehC,EAAK,CACtBmB,KAAMC,EAAgBC,QAAAA,QAAQ,sBAAuB,IACrD3B,KAAO,8UAWP4B,SAAU,CACNW,aAAcjC,EAAKwB,KAAK,YAE5BM,WAAY,CACRd,SAAAA,GAEJe,MAAO,IAGLG,EAAWlC,EAAK,CAClBmB,KAAMC,EAAgBC,QAAAA,QAAQ,sBAAuB,IACrD3B,KAAMyC,EAAad,QAAAA,QAAQ,sBAAuB,IAClDC,SAAU,CACNc,YAAapC,EAAKwB,KAAK,UACvBa,SAAUrC,EAAKwB,KAAK,YACpB5B,OAAQI,EAAKwB,KAAK,UAClBG,OAAQ3B,EAAKwB,KAAK,UAClBD,WAAYvB,EAAKwB,KAAK,eAE1BM,WAAY,CACRd,SAAAA,GAEJe,MAAO,IAwDJ,MAAA,CACH/B,KAAAA,EACAgC,aAAAA,EACAM,oBArDMA,UAAoBC,GACpBC,MAAAA,EAAMnC,IACZmC,EAAIC,IAAI,KACJvB,EAAS,EAAA,CACLK,WAAY,CAACzB,EAAQF,EAAO,GAAIG,EAASH,EAAO,IAChD+B,OAAQ,CAAC,EAAE,GACX/B,OAAAA,GACG2C,IAEPG,QAAQC,IAAI,mCAAoC3C,EAAK4C,gBAEnDJ,EAEFK,IAAAA,EAAsBrC,IAC1BqC,EAAoBJ,IAAI,KACpBT,EAAa,CAAE9B,QAASsC,MAGtBM,MAAAA,EAAkB,CAACC,EAAsBpB,KACrCqB,MAAAA,EAAe3C,IACrB2C,EAAaP,IAAI,KACbvB,EAAS,EAAA,CACLK,WAAY,CAACzB,EAAQF,EAAO,GAAIG,EAASH,EAAO,IAChD+B,OAAAA,EACA/B,OAAAA,GACG2C,MAILU,MAAAA,EAAkBzC,IAUjByC,OATPA,EAAgBR,IAAI,KAChBP,EAAS,CACLgB,OAAQF,EACRX,SAAUU,EACVnD,OAAAA,EACA+B,OAAAA,EACAJ,WAAY,CAACzB,EAAOC,OAGrBkD,GAGN,IAAA,IAAItB,KAAU9B,EACfgD,EAAsBC,EAAgBD,EAAqBlB,SACrDkB,EAGHA,OAAAA,IAUApD,IAAAA,EAAAA,EAAAA,QAAAA,QAAAA;;AC9GA0D,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EA/Df,IAAA,EAAA,EAAA,QAAA,sBACA,EAAA,EAAA,QAAA,kBACA,EAAA,EAAA,QAAA,OA6DeA,SAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,QAAAA,GA3Df,MAAMA,EAAQ,CAACrD,EAAQ,IAAMC,EAAS,OAC5BH,MAEAwD,GAAY,EAAWtD,EAAAA,SAAAA,EAAOC,EAAQ,CAAEsD,uBAAuB,IAE/DC,GAAW,EAAc,EAAA,SAAA,CAC3B5D,KAAM6D,EAAelC,QAAAA,QAAQ,oBAAqB,IAClD1B,YAAayD,EACbxD,OAPW,CAAC,EAAG,GAQfC,QAPY,GAQZC,MAAAA,EACAC,OAAAA,IAGEyD,EAAeC,IACXC,MAAAA,EAAQJ,EAAShB,oBAAoBmB,GACvCE,IAAAA,EAAOD,EAAME,OACV,MAACD,EAAKE,MACTF,EAAOD,EAAME,OAEXpB,MAAAA,EAAMmB,EAAKG,MAIXR,OAHNA,EAAStB,aAAa,CAAE9B,QAASsC,IACjCE,QAAQC,IAAIW,EAAStD,KAAK4C,QAEpBU,EAAStD,KAAK4C,QA6BjB,MAAA,CACHY,YAAAA,EACAO,aA5BiB,CAACC,EAAQC,EAAM,MAC1BC,MAAAA,EAAQF,EAAO,GAEfG,GADOH,EAAOA,EAAOI,OAAS,GACbC,KAAOH,EAAMG,MAAQ,IACtCC,EAAYnE,KAAKoE,KAAKJ,GAAY,IAAOF,IAEzCO,EAAU,GAEX,IAAA,IAAIC,EAAI,EAAGA,EAAIH,EAAWG,IAAK,CAC1BJ,MAAAA,EAAOI,GAAK,IAAOR,GACnBS,EAAkBV,EAAOW,UAAWC,GAAUA,EAAMP,KAAOH,EAAMG,MAAQA,GAC3EK,IAAqB,IAArBA,EAAwB,MAC5BhC,QAAQC,IAAI+B,GACNG,MAAAA,EAAab,EAAOU,GAQ1BF,EAAQM,KAAKtB,EAAYqB,EAAWpB,QAEjCe,OAAAA,KASArB,IAAAA,EAAAA,EAAAA,QAAAA,QAAAA;;ACXf,aApDA,IAAA,EAAA,EAAA,QAAA,mBACA,EAAA,EAAA,QAAA,YACA,EAAA,EAAA,QAAA,SACA,EAAA,EAAA,QAAA,gBACA,EAAA,QAAA,eAgDA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,SAAA,EAAA,EAAA,GAAA,IAAA,EAAA,OAAA,KAAA,GAAA,GAAA,OAAA,sBAAA,CAAA,IAAA,EAAA,OAAA,sBAAA,GAAA,IAAA,EAAA,EAAA,OAAA,SAAA,GAAA,OAAA,OAAA,yBAAA,EAAA,GAAA,cAAA,EAAA,KAAA,MAAA,EAAA,GAAA,OAAA,EAAA,SAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,UAAA,OAAA,IAAA,CAAA,IAAA,EAAA,MAAA,UAAA,GAAA,UAAA,GAAA,GAAA,EAAA,EAAA,EAAA,OAAA,IAAA,GAAA,QAAA,SAAA,GAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,0BAAA,OAAA,iBAAA,EAAA,OAAA,0BAAA,IAAA,EAAA,OAAA,IAAA,QAAA,SAAA,GAAA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,KAAA,EAAA,OAAA,eAAA,EAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,GAAA,EAAA,EA/CA,MAAM4B,GAAM,EAAZ,EAAA,WACAA,EAAItC,KAAI,EAAR,EAAA,YACAsC,EAAItC,IAAIuC,EAAWC,QAAAA,QACnB,MAAMC,EAAO,IAEPpF,EAAQ,IACRC,EAAS,IACToF,GAAW,EAAiBrF,EAAAA,SAFpB,IACC,KAGTsF,EAAmBpB,GACdA,EAAOqB,IAAIT,GAEPA,EAAAA,EAAAA,GAAAA,GADP,GAAA,CAEInB,MACOmB,EAAAA,EAAAA,GAAAA,EAAMnB,OADR,GAAA,CAED/B,gBAAiB4D,OAAOC,OAAOX,EAAMnB,MAAM/B,sBAM3DqD,EAAIS,IAAI,IAAK,CAACC,EAAKC,KAEjBA,EAAIC,KAAK,kBAGXZ,EAAIa,KAAK,UAAW,MAAOH,EAAKC,KAAQ,IAAA,EAE9B1B,MAAAA,EAASmB,EAASpB,aAAaqB,EAAgB,QAAAK,EAAAA,EAAII,YAAJ,IAAA,OAAA,EAAA,EAAU7B,SACzD8B,EAAOC,OAAOC,KAAKhC,EAAOA,EAAOI,OAAS,IAChD1B,QAAQC,IAAImD,SAEN,EAAa,EAAA,cAAA,YAAaA,EAAM,CAClChG,MA5BM,IA6BNC,OA5BO,MA8BX2F,EAAIC,KAAK,oBAWbZ,EAAIkB,OA5CS,IA4CI,KACfvD,QAAQC,IAAK","file":"main.js","sourceRoot":"..","sourcesContent":["module.exports=\"precision highp float;\\n#define GLSLIFY 1\\nuniform vec2 screenSize;\\nuniform vec2 offset;\\nuniform vec2 repeat;\\nuniform float time;\\nuniform vec3 cameraPosition;\\nuniform mat4 cameraDirection;\\nuniform bool onlyDistance;\\nuniform float scrollX;\\nuniform float scrollY;\\n\\nconst float hitThreshold = 0.00015;\\nconst int MAX_ITER = 200;\\n\\nconst vec3 spaceRepetition = vec3(3.5);\\n\\nvec3 getRay() {\\n    vec2 normalizedCoords = gl_FragCoord.xy - vec2(0.5) + (offset / repeat);\\n    vec2 pixel = (normalizedCoords - 0.5 * screenSize) / min(screenSize.x, screenSize.y);\\n\\n    // as if the higher the pixel value, the more the offset is being applied\\n    // normalize to get unit vector\\n    return (cameraDirection * normalize(vec4(pixel.x, pixel.y, 1, 0))).xyz;\\n}\\n\\nvec3 opRepeat(vec3 p, vec3 distance) {\\n    return mod(p + 0.5 * distance, distance) - 0.5 * distance;\\n}\\n\\nfloat doModel(vec3 p) {\\n    vec3 pos = opRepeat(p, spaceRepetition);\\n\\tvec3 z = pos;\\n\\tfloat dr = 1.0;\\n\\tfloat r = 0.0;\\n\\tfor (int i = 0; i < 10; i++) {\\n\\t\\tr = length(z);\\n\\t\\tif (r > 4.) break;\\n\\t\\t\\n\\t\\t// convert to polar coordinates\\n\\t\\tfloat theta = acos(z.z / r);\\n\\t\\tfloat phi = atan(z.y, z.x);\\n        float power = 12. + sin(scrollY) * 10.;\\n\\t\\tdr =  pow(r, power - 1.) * power * dr + 1.5;\\n\\t\\t\\n\\t\\t// scale and rotate the point\\n\\t\\tfloat zr = pow(r, power);\\n\\t\\ttheta = theta * power;\\n\\t\\tphi = phi * power;\\n\\t\\t\\n\\t\\t// convert back to cartesian coordinates\\n\\t\\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\\n\\t\\tz += pos;\\n\\t}\\n\\treturn abs(0.5 * log(r) * r / dr);\\n}\\n// this is kinda contrived and does a bunch of stuff I'm not using right now, but I'll leave it like this for now\\nvec3 trace(vec3 origin, vec3 direction, out int iterations) {\\n    vec3 position = origin;\\n    float distanceTraveled = 0.;\\n    mat3 scrollXRotate = mat3(\\n        1,  sin(scrollX) * 0.05, 0,\\n        -sin(scrollX) * 0.05, 1, 0,\\n        0,             0,            1\\n    );\\n    for(int i = 0; i < MAX_ITER; i++) {\\n        iterations = i;\\n        float d = doModel(position);\\n        if (d < hitThreshold * distanceTraveled) break;\\n        position += d * direction;\\n        direction = scrollXRotate * direction;\\n        distanceTraveled += d;\\n    }\\n    return position;\\n}\\n\\nfloat getIllumination(vec3 collision, int iterations) {\\n    float occlusionLight = 1. - float(iterations) / float(MAX_ITER);\\n    return occlusionLight;\\n}\\n\\n// const float col = 0.05; // amount of coloring\\n\\nvec3 hsl2rgb( in vec3 c ) {\\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\\n}\\n\\nvec3 getColor(float it, float d) {\\n    return hsl2rgb(vec3(\\n        d,\\n        0.5,\\n        1. - pow(it, 0.8)\\n    ));\\n}\\n\\nvoid main() {\\n    gl_FragColor = vec4(1, 0, 0, 1);\\n    return;\\n    vec3 direction = getRay();\\n    // gl_FragColor = vec4(offset / (repeat - vec2(1)), 0, 1);\\n    // return;\\n\\n    // gl_FragColor = vec4(opRepeat(cameraPosition, vec3(2.5)), 1);\\n    // return;\\n\\n    int iterations;\\n    vec3 collision = trace(cameraPosition, direction, iterations);\\n    gl_FragColor = vec4(\\n        getColor(float(iterations) / float(MAX_ITER), distance(collision, spaceRepetition / 2.)),\\n        1.\\n    );\\n}\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\nattribute vec2 position;\\nvarying vec2 uv;\\nvoid main() {\\n    uv = position;\\n    gl_Position = vec4(position, 0, 1);\\n}\";","module.exports=\"precision highp float;\\nprecision mediump sampler2D;\\n#define GLSLIFY 1\\nuniform sampler2D inputSample;\\nuniform sampler2D previous;\\nuniform vec2 offset;\\nuniform vec2 repeat;\\nuniform vec2 screenSize;\\n\\nconst vec2 pixelOffset = vec2(0.499);\\n\\nvec2 modulo (vec2 a, vec2 b) {\\n    vec2 d = floor(a / b);\\n    vec2 q = d * b;\\n    return a - q;\\n}\\n\\nfloat getMixFactor (vec2 position) {\\n    vec2 rest = modulo(position, repeat);\\n    vec2 diff = abs(rest - (offset));\\n    return 1. - min(max(diff.x, diff.y), 1.);\\n}\\n\\nvoid main () {\\n    vec2 position = gl_FragCoord.xy - pixelOffset;\\n    vec2 pixel = position / screenSize;\\n\\n    vec4 previousColor = texture2D(previous, pixel);\\n    vec4 newColor = texture2D(inputSample, pixel);\\n\\n    gl_FragColor = mix(previousColor, newColor, getMixFactor(position));\\n}\\n\\n// 1, 3 position\\n// 1, 0 offset\\n// 3, 3 repeat\\n\\n// 1, 0 rest\\n// 0, 0 diff\\n// 0 mix factor\\n\\n// 1 - 3 * floor(1/3) = 0 -> want it to be 2\\n// 3 - 3\\n\\n// 0, 3 = 0 -> 0 - 3 * floor (0 / 3) = 0\\n// 1, 3 = 1 -> 1 - 3 * floor (1 / 3) = 1;\\n// 2, 3 = 2 -> 2 - 3 * floor (2 / 3) = 2\\n// 3, 3 = 0 -> 3 - 3 * floor (3 / 3) = 0\\n// 4, 3 = 1 -> 4 - 3 * floor (4 / 3) = 1\\n// 5, 3 = 2\\n// 6, 3 = 0\\n// 7, 3 = 1\\n\\n// 1, 3 -> 1, 0\\n\\n// 2, 3 position\\n// 2, 0 offset\\n// 3, 3 repeat\\n\\n// restX = mod(2, 3) = 2 - 3 * floor(2 / 3) = 2\\n// restY = mod(3, 3) = 3 - 3 * floor(3 / 3) = 0\\n// 2, 0 rest\\n// diff = (2, 0) - (2, 0) = (0, 0)\\n// 1 - min(max(0,0), 1) = 0\";","import Regl from 'regl';\nimport passThroughVert from './pass-through-vert.glsl';\nimport upSampleFrag from './upsample.glsl';\n\nfunction setupRenderer({\n    frag,\n    reglContext,\n    repeat = [1, 1],\n    offsets = [],\n    width,\n    height,\n}) {\n    const regl = Regl(reglContext); // no params = full screen canvas\n    \n    // The FBO the actual SDF samples are rendered into\n    let sdfTexture = regl.texture({\n        width: Math.round(width / repeat[0]),\n        height: Math.round(height / repeat[1])\n    });\n    const getSDFFBO = () => regl.framebuffer({ color: sdfTexture });\n    \n    // We need a double buffer in order to progressively add samples for each render step\n    const createPingPongBuffers = textureOptions => {\n        const tex1 = regl.texture(textureOptions);\n        const tex2 = regl.texture(textureOptions);\n        const one = regl.framebuffer({\n          color: tex1\n        });\n        const two = regl.framebuffer({\n          color: tex2\n        });\n        let counter = 0;\n        return () => {\n            counter++;\n            if (counter % 2 === 0) {\n                return one({ color: tex1 });\n            }\n            return two({ color: tex2 });\n        }\n    };\n    \n    let getScreenFBO = createPingPongBuffers({\n        width,\n        height,\n    });\n    \n    // screen-filling rectangle\n    const position = regl.buffer([\n        [-1, -1],\n        [1, -1],\n        [1,  1],\n        [-1, -1],   \n        [1, 1,],\n        [-1, 1]\n    ]);\n    \n    const renderSDF = regl({\n        frag,\n        vert: passThroughVert.replace(\"#define GLSLIFY 1\", \"\"),\n        uniforms: {\n            screenSize: regl.prop('screenSize'),\n            cameraPosition: regl.prop('cameraPosition'),\n            cameraDirection: regl.prop('cameraDirection'),\n            offset: regl.prop('offset'),\n            repeat: regl.prop('repeat'),\n            scrollX: regl.prop('scrollX'),\n            scrollY: regl.prop('scrollY'),\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    // render texture to screen\n    const drawToCanvas = regl({\n        vert: passThroughVert.replace(\"#define GLSLIFY 1\\n\", \"\"),\n        frag: `\n            precision highp float;\n            uniform sampler2D inputTexture;\n            varying vec2 uv;\n    \n            void main () {\n              vec4 color = texture2D(inputTexture, uv * 0.5 + 0.5);\n            //   vec4 color = vec4(uv.x, uv.y, 0, 1);\n              gl_FragColor = color;\n            }\n        `,\n        uniforms: {\n            inputTexture: regl.prop('texture'),\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    const upSample = regl({\n        vert: passThroughVert.replace(\"#define GLSLIFY 1\\n\", \"\"),\n        frag: upSampleFrag.replace(\"#define GLSLIFY 1\\n\", \"\"),\n        uniforms: {\n            inputSample: regl.prop('sample'), // sampler2D\n            previous: regl.prop('previous'), // sampler2D\n            repeat: regl.prop('repeat'), // vec2\n            offset: regl.prop('offset'), // vec2\n            screenSize: regl.prop('screenSize'), // vec2\n        },\n        attributes: {\n            position\n        },\n        count: 6,\n    });\n    \n    // This generates each of the render steps, to be used in the main animation loop\n    // By pausing the execution of this function, we can let the main thread handle events, gc, etc. between steps\n    // It also allows us to bail early in case we ran out of time\n    function* generateRenderSteps(renderState){\n        const fbo = getSDFFBO();\n        fbo.use(() => {\n            renderSDF({\n                screenSize: [width / repeat[0], height / repeat[1]],\n                offset: [0,0],\n                repeat,\n                ...renderState\n            });\n            console.log(\"hier moet het eigenlijk 255 zijn\", regl.read());\n        });\n        yield fbo;\n        \n        let currentScreenBuffer = getScreenFBO();\n        currentScreenBuffer.use(() => {\n            drawToCanvas({ texture: fbo });\n        });\n    \n        const performUpSample = (previousScreenBuffer, offset) => {\n            const newSampleFBO = getSDFFBO();\n            newSampleFBO.use(() => {\n                renderSDF({\n                    screenSize: [width / repeat[0], height / repeat[1]],\n                    offset,\n                    repeat,\n                    ...renderState\n                });\n            });\n    \n            const newScreenBuffer = getScreenFBO();\n            newScreenBuffer.use(() => {\n                upSample({\n                    sample: newSampleFBO,\n                    previous: previousScreenBuffer,\n                    repeat,\n                    offset,\n                    screenSize: [width, height],\n                });\n            });\n            return newScreenBuffer;\n        }\n    \n        for (let offset of offsets) {\n            currentScreenBuffer = performUpSample(currentScreenBuffer, offset);\n            yield currentScreenBuffer;\n        }\n        // also return the current screenbuffer so the last next() on the generator still gives a reference to what needs to be drawn\n        return currentScreenBuffer;\n    };\n\n    return {\n        regl,\n        drawToCanvas, // will draw fbo to canvas (or whatever was given as regl context)\n        generateRenderSteps, // generator that yields FBOs, that can be drawn to the canvas\n    }\n}\n\nexport default setupRenderer;\n","import fragmentShader from './mandelbulb.glsl';\nimport setupRenderer from './renderer.js';\nimport headlessGL from \"gl\";\n\nconst setup = (width = 1000, height = 1000) => {\n    const repeat = [1, 1];\n    const offsets = [];\n    const container = headlessGL(width, height, { preserveDrawingBuffer: true });\n\n    const renderer = setupRenderer({\n        frag: fragmentShader.replace(\"#define GLSLIFY 1\", \"\"),\n        reglContext: container,\n        repeat,\n        offsets,\n        width,\n        height,\n    });\n\n    const renderFrame = (state) => {\n        const steps = renderer.generateRenderSteps(state);\n        let step = steps.next();\n        while (!step.done) { // this shouldn't be necessary since we shouldn't be generating more than one render step\n            step = steps.next();\n        }\n        const fbo = step.value;\n        renderer.drawToCanvas({ texture: fbo });\n        console.log(renderer.regl.read());\n\n       return renderer.regl.read();\n    }\n\n    const renderFrames = (frames, fps = 60) => {\n        const first = frames[0];\n        const last = frames[frames.length - 1];\n        const timespan = (last.time - first.time) / 1000;\n        const numFrames = Math.ceil(timespan / (1000 / fps));\n\n        const outputs = [];\n\n        for (let i = 0; i < numFrames; i++) {\n            const time = i * (1000 / fps);\n            const startFrameIndex = frames.findIndex((frame) => frame.time - first.time >= time);\n            if (startFrameIndex === -1) break;\n            console.log(startFrameIndex);\n            const startFrame = frames[startFrameIndex];\n            \n            // now interpolate all state\n            // const endFrame = frames[startFrameIndex + 1] || startFrame;\n            // const progress = (time - startFrame.time) / (endFrame.time - startFrame.time);\n            // For now, just take start frame and don't interpolate because it requires some refactoring\n            // i.e. use quaternion instead of direction matrix so interpolation is easier\n            // console.log(startFrame.state);\n            outputs.push(renderFrame(startFrame.state));\n        }\n        return outputs//.map(image => image.filter(Boolean));\n    }\n\n    return { \n        renderFrame,\n        renderFrames,\n    };\n};\n\nexport default setup;\n","import headlessRenderer from '../headless.js';\nimport express from \"express\";\nimport cors from \"cors\";\nimport bodyParser from \"body-parser\";\nimport { writePngFile } from \"node-libpng\";\nconst app = express();\napp.use(cors());\napp.use(bodyParser.json());\nconst port = 3000;\n\nconst width = 100;\nconst height = 100;\nconst headless = headlessRenderer(width, height);\n\nconst transformFrames = (frames) => {\n    return frames.map(frame => {\n        return {\n            ...frame,\n            state: {\n                ...frame.state,\n                cameraDirection: Object.values(frame.state.cameraDirection), // turn from object with string indices into array\n            }\n        }\n    })\n}\n\napp.get('/', (req, res) => {\n\n  res.send('Hello World!')\n});\n\napp.post('/render', async (req, res) => {\n    // console.log(req.body);\n    const frames = headless.renderFrames(transformFrames(req.body?.frames));\n    const data = Buffer.from(frames[frames.length - 1]);\n    console.log(data);\n    // fs.writeFileSync(`pic.png`, data, 'binary');\n    await writePngFile(\"image.png\", data, {\n        width,\n        height,\n    });\n    res.send('Great success!');\n    /**\n     * So basically:\nit takes endTimeStamp - beginTimeStamp to get the whole timespan\nThen picks points in time along that timespan so that it has 60fps\nFor each point, interpolate the state\nWith that interpolated state, render a frame to img file (e.g. png)\nThen, once complete for all frames, encode into a video using ffmpeg\n     */\n})\n\napp.listen(port, () => {\n  console.log(`Example app listening at http://localhost:${port}`)\n})"]}