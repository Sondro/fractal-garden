parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"PqeC":[function(require,module,exports) {
module.exports="precision highp float;\n#define GLSLIFY 1\nuniform vec2 screenSize;\nuniform vec2 offset;\nuniform vec2 repeat;\nuniform float time;\nuniform vec3 cameraPosition;\nuniform mat4 cameraDirection;\nuniform bool onlyDistance;\nuniform float scrollX;\nuniform float scrollY;\n\nconst float hitThreshold = 0.00015;\nconst int MAX_ITER = 200;\n\nconst vec3 spaceRepetition = vec3(3.5);\n\nvec3 getRay() {\n    vec2 normalizedCoords = gl_FragCoord.xy - vec2(0.5) + (offset / repeat);\n    vec2 pixel = (normalizedCoords - 0.5 * screenSize) / min(screenSize.x, screenSize.y);\n\n    // as if the higher the pixel value, the more the offset is being applied\n    // normalize to get unit vector\n    return (cameraDirection * normalize(vec4(pixel.x, pixel.y, 1, 0))).xyz;\n}\n\nvec3 opRepeat(vec3 p, vec3 distance) {\n    return mod(p + 0.5 * distance, distance) - 0.5 * distance;\n}\n\nfloat doModel(vec3 p) {\n    vec3 pos = opRepeat(p, spaceRepetition);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tr = length(z);\n\t\tif (r > 4.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n        float power = 12. + sin(scrollY) * 10.;\n\t\tdr =  pow(r, power - 1.) * power * dr + 1.5;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn abs(0.5 * log(r) * r / dr);\n}\n// this is kinda contrived and does a bunch of stuff I'm not using right now, but I'll leave it like this for now\nvec3 trace(vec3 origin, vec3 direction, out int iterations) {\n    vec3 position = origin;\n    float distanceTraveled = 0.;\n    mat3 scrollXRotate = mat3(\n        1,  sin(scrollX) * 0.05, 0,\n        -sin(scrollX) * 0.05, 1, 0,\n        0,             0,            1\n    );\n    for(int i = 0; i < MAX_ITER; i++) {\n        iterations = i;\n        float d = doModel(position);\n        if (d < hitThreshold * distanceTraveled) break;\n        position += d * direction;\n        direction = scrollXRotate * direction;\n        distanceTraveled += d;\n    }\n    return position;\n}\n\nfloat getIllumination(vec3 collision, int iterations) {\n    float occlusionLight = 1. - float(iterations) / float(MAX_ITER);\n    return occlusionLight;\n}\n\n// const float col = 0.05; // amount of coloring\n\nvec3 hsl2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 getColor(float it, float d) {\n    return hsl2rgb(vec3(\n        d,\n        0.5,\n        1. - pow(it, 0.8)\n    ));\n}\n\nvoid main() {\n    vec3 direction = getRay();\n    // gl_FragColor = vec4(offset / (repeat - vec2(1)), 0, 1);\n    // return;\n\n    // gl_FragColor = vec4(opRepeat(cameraPosition, vec3(2.5)), 1);\n    // return;\n\n    int iterations;\n    vec3 collision = trace(cameraPosition, direction, iterations);\n    gl_FragColor = vec4(\n        getColor(float(iterations) / float(MAX_ITER), distance(collision, spaceRepetition / 2.)),\n        1.\n    );\n}";
},{}],"Tb0D":[function(require,module,exports) {
module.exports="precision highp float;\n#define GLSLIFY 1\nattribute vec2 position;\nvarying vec2 uv;\nvoid main() {\n    uv = position;\n    gl_Position = vec4(position, 0, 1);\n}";
},{}],"GMqR":[function(require,module,exports) {
module.exports="precision highp float;\nprecision mediump sampler2D;\n#define GLSLIFY 1\nuniform sampler2D sample;\nuniform sampler2D previous;\nuniform vec2 offset;\nuniform vec2 repeat;\nuniform vec2 screenSize;\n\nconst vec2 pixelOffset = vec2(0.499);\n\nvec2 modulo (vec2 a, vec2 b) {\n    vec2 d = floor(a / b);\n    vec2 q = d * b;\n    return a - q;\n}\n\nfloat getMixFactor (vec2 position) {\n    vec2 rest = modulo(position, repeat);\n    vec2 diff = abs(rest - (offset));\n    return 1. - min(max(diff.x, diff.y), 1.);\n}\n\nvoid main () {\n    vec2 position = gl_FragCoord.xy - pixelOffset;\n    vec2 pixel = position / screenSize;\n\n    vec4 previousColor = texture2D(previous, pixel);\n    vec4 newColor = texture2D(sample, pixel);\n\n    gl_FragColor = mix(previousColor, newColor, getMixFactor(position));\n}\n\n// 1, 3 position\n// 1, 0 offset\n// 3, 3 repeat\n\n// 1, 0 rest\n// 0, 0 diff\n// 0 mix factor\n\n// 1 - 3 * floor(1/3) = 0 -> want it to be 2\n// 3 - 3\n\n// 0, 3 = 0 -> 0 - 3 * floor (0 / 3) = 0\n// 1, 3 = 1 -> 1 - 3 * floor (1 / 3) = 1;\n// 2, 3 = 2 -> 2 - 3 * floor (2 / 3) = 2\n// 3, 3 = 0 -> 3 - 3 * floor (3 / 3) = 0\n// 4, 3 = 1 -> 4 - 3 * floor (4 / 3) = 1\n// 5, 3 = 2\n// 6, 3 = 0\n// 7, 3 = 1\n\n// 1, 3 -> 1, 0\n\n// 2, 3 position\n// 2, 0 offset\n// 3, 3 repeat\n\n// restX = mod(2, 3) = 2 - 3 * floor(2 / 3) = 2\n// restY = mod(3, 3) = 3 - 3 * floor(3 / 3) = 0\n// 2, 0 rest\n// diff = (2, 0) - (2, 0) = (0, 0)\n// 1 - min(max(0,0), 1) = 0";
},{}],"QpQU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=o(require("regl")),r=o(require("./pass-through-vert.glsl")),t=o(require("./upsample.glsl"));function o(e){return e&&e.__esModule?e:{default:e}}function n(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function s(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?n(Object(t),!0).forEach(function(r){u(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}function u(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i({frag:o,reglContext:n,repeat:u=[1,1],offsets:i=[],width:c,height:p}){console.log(n);const a=(0,e.default)(n);let f=a.texture({width:Math.round(c/u[0]),height:Math.round(p/u[1])});const l=a.framebuffer({color:f}),g=()=>l({color:f});let b=(e=>{const r=a.texture(e),t=a.texture(e),o=a.framebuffer({color:r}),n=a.framebuffer({color:t});let s=0;return()=>++s%2==0?o({color:r}):n({color:t})})({width:c,height:p});const d=a.buffer([[-1,-1],[1,-1],[1,1],[-1,-1],[1,1],[-1,1]]),v=a({context:{},frag:o,vert:r.default,uniforms:{screenSize:a.prop("screenSize"),cameraPosition:a.prop("cameraPosition"),cameraDirection:a.prop("cameraDirection"),offset:a.prop("offset"),repeat:a.prop("repeat"),scrollX:a.prop("scrollX"),scrollY:a.prop("scrollY")},attributes:{position:d},count:6}),m=a({vert:r.default,frag:"\n            precision highp float;\n            uniform sampler2D texture;\n            varying vec2 uv;\n    \n            void main () {\n              vec4 color = texture2D(texture, uv * 0.5 + 0.5);\n              gl_FragColor = color;\n            }\n        ",uniforms:{texture:a.prop("texture")},attributes:{position:d},count:6}),h=a({vert:r.default,frag:t.default,uniforms:{sample:a.prop("sample"),previous:a.prop("previous"),repeat:a.prop("repeat"),offset:a.prop("offset"),screenSize:a.prop("screenSize")},attributes:{position:d},count:6});return{regl:a,drawToCanvas:m,generateRenderSteps:function*(e){const r=g();r.use(()=>{v(s({screenSize:[c/u[0],p/u[1]],offset:[0,0],repeat:u},e))}),yield r;let t=b();t.use(()=>{m({texture:r})});const o=(r,t)=>{const o=g();o.use(()=>{v(s({screenSize:[c/u[0],p/u[1]],offset:t,repeat:u},e))});const n=b();return n.use(()=>{h({sample:o,previous:r,repeat:u,offset:t,screenSize:[c,p]})}),n};for(let n of i)t=o(t,n),yield t;return t}}}var c=i;exports.default=c;
},{"./pass-through-vert.glsl":"Tb0D","./upsample.glsl":"GMqR"}],"redA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=u(require("./mandelbulb.glsl")),r=u(require("./renderer.js")),t=u(require("headless-gl"));function u(e){return e&&e.__esModule?e:{default:e}}const a=(u=1e3,a=1e3)=>{const n=(0,t.default)(u,a,{preserveDrawingBuffer:!0}),s=(0,r.default)({frag:e.default,reglContext:n,repeat:[1,1],offsets:[],width:u,height:a});return e=>{const r=s.generateRenderSteps(e);let t=r.next();for(;!t.done;)t=r.next();const u=t.value;return s.drawToCanvas({texture:u}),s.regl.read()}};var n=a;exports.default=n;
},{"./mandelbulb.glsl":"PqeC","./renderer.js":"QpQU"}],"epB2":[function(require,module,exports) {
"use strict";var e=r(require("../headless.js")),s=r(require("express")),o=r(require("cors")),l=r(require("body-parser"));function r(e){return e&&e.__esModule?e:{default:e}}console.log("hahaha",e.default);const t=(0,s.default)();t.use((0,o.default)()),t.use(l.default.json());const a=3e3;t.get("/",(e,s)=>{s.send("Hello World!")}),t.post("/render",(e,s)=>{console.log(e.body),s.send("Great success!")}),t.listen(3e3,()=>{console.log("Example app listening at http://localhost:3000")});
},{"../headless.js":"redA"}]},{},["epB2"], null)
//# sourceMappingURL=/main.js.map