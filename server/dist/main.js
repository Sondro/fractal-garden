parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"PqeC":[function(require,module,exports) {
module.exports="precision highp float;\n#define GLSLIFY 1\nuniform vec2 screenSize;\nuniform vec2 offset;\nuniform vec2 repeat;\nuniform float time;\nuniform vec3 cameraPosition;\nuniform mat4 cameraDirection;\nuniform bool onlyDistance;\nuniform float scrollX;\nuniform float scrollY;\n\nconst float hitThreshold = 0.00015;\nconst int MAX_ITER = 200;\n\nconst vec3 spaceRepetition = vec3(3.5);\n\nvec3 getRay() {\n    vec2 normalizedCoords = gl_FragCoord.xy - vec2(0.5) + (offset / repeat);\n    vec2 pixel = (normalizedCoords - 0.5 * screenSize) / min(screenSize.x, screenSize.y);\n\n    // as if the higher the pixel value, the more the offset is being applied\n    // normalize to get unit vector\n    return (cameraDirection * normalize(vec4(pixel.x, pixel.y, 1, 0))).xyz;\n}\n\nvec3 opRepeat(vec3 p, vec3 distance) {\n    return mod(p + 0.5 * distance, distance) - 0.5 * distance;\n}\n\nfloat doModel(vec3 p) {\n    vec3 pos = opRepeat(p, spaceRepetition);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 10; i++) {\n\t\tr = length(z);\n\t\tif (r > 4.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n        float power = 12. + sin(scrollY) * 10.;\n\t\tdr =  pow(r, power - 1.) * power * dr + 1.5;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\treturn abs(0.5 * log(r) * r / dr);\n}\n// this is kinda contrived and does a bunch of stuff I'm not using right now, but I'll leave it like this for now\nvec3 trace(vec3 origin, vec3 direction, out int iterations) {\n    vec3 position = origin;\n    float distanceTraveled = 0.;\n    mat3 scrollXRotate = mat3(\n        1,  sin(scrollX) * 0.05, 0,\n        -sin(scrollX) * 0.05, 1, 0,\n        0,             0,            1\n    );\n    for(int i = 0; i < MAX_ITER; i++) {\n        iterations = i;\n        float d = doModel(position);\n        if (d < hitThreshold * distanceTraveled) break;\n        position += d * direction;\n        direction = scrollXRotate * direction;\n        distanceTraveled += d;\n    }\n    return position;\n}\n\nfloat getIllumination(vec3 collision, int iterations) {\n    float occlusionLight = 1. - float(iterations) / float(MAX_ITER);\n    return occlusionLight;\n}\n\n// const float col = 0.05; // amount of coloring\n\nvec3 hsl2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 getColor(float it, float d) {\n    return hsl2rgb(vec3(\n        d,\n        0.5,\n        1. - pow(it, 0.8)\n    ));\n}\n\nvoid main() {\n    gl_FragColor = vec4(1, 0, 0, 1);\n    return;\n    vec3 direction = getRay();\n    // gl_FragColor = vec4(offset / (repeat - vec2(1)), 0, 1);\n    // return;\n\n    // gl_FragColor = vec4(opRepeat(cameraPosition, vec3(2.5)), 1);\n    // return;\n\n    int iterations;\n    vec3 collision = trace(cameraPosition, direction, iterations);\n    gl_FragColor = vec4(\n        getColor(float(iterations) / float(MAX_ITER), distance(collision, spaceRepetition / 2.)),\n        1.\n    );\n}";
},{}],"Tb0D":[function(require,module,exports) {
module.exports="precision highp float;\n#define GLSLIFY 1\nattribute vec2 position;\nvarying vec2 uv;\nvoid main() {\n    uv = position;\n    gl_Position = vec4(position, 0, 1);\n}";
},{}],"GMqR":[function(require,module,exports) {
module.exports="precision highp float;\nprecision mediump sampler2D;\n#define GLSLIFY 1\nuniform sampler2D inputSample;\nuniform sampler2D previous;\nuniform vec2 offset;\nuniform vec2 repeat;\nuniform vec2 screenSize;\n\nconst vec2 pixelOffset = vec2(0.499);\n\nvec2 modulo (vec2 a, vec2 b) {\n    vec2 d = floor(a / b);\n    vec2 q = d * b;\n    return a - q;\n}\n\nfloat getMixFactor (vec2 position) {\n    vec2 rest = modulo(position, repeat);\n    vec2 diff = abs(rest - (offset));\n    return 1. - min(max(diff.x, diff.y), 1.);\n}\n\nvoid main () {\n    vec2 position = gl_FragCoord.xy - pixelOffset;\n    vec2 pixel = position / screenSize;\n\n    vec4 previousColor = texture2D(previous, pixel);\n    vec4 newColor = texture2D(inputSample, pixel);\n\n    gl_FragColor = mix(previousColor, newColor, getMixFactor(position));\n}\n\n// 1, 3 position\n// 1, 0 offset\n// 3, 3 repeat\n\n// 1, 0 rest\n// 0, 0 diff\n// 0 mix factor\n\n// 1 - 3 * floor(1/3) = 0 -> want it to be 2\n// 3 - 3\n\n// 0, 3 = 0 -> 0 - 3 * floor (0 / 3) = 0\n// 1, 3 = 1 -> 1 - 3 * floor (1 / 3) = 1;\n// 2, 3 = 2 -> 2 - 3 * floor (2 / 3) = 2\n// 3, 3 = 0 -> 3 - 3 * floor (3 / 3) = 0\n// 4, 3 = 1 -> 4 - 3 * floor (4 / 3) = 1\n// 5, 3 = 2\n// 6, 3 = 0\n// 7, 3 = 1\n\n// 1, 3 -> 1, 0\n\n// 2, 3 position\n// 2, 0 offset\n// 3, 3 repeat\n\n// restX = mod(2, 3) = 2 - 3 * floor(2 / 3) = 2\n// restY = mod(3, 3) = 3 - 3 * floor(3 / 3) = 0\n// 2, 0 rest\n// diff = (2, 0) - (2, 0) = (0, 0)\n// 1 - min(max(0,0), 1) = 0";
},{}],"QpQU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=o(require("regl")),r=o(require("./pass-through-vert.glsl")),t=o(require("./upsample.glsl"));function o(e){return e&&e.__esModule?e:{default:e}}function n(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?n(Object(t),!0).forEach(function(r){u(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}function u(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function p({frag:o,reglContext:n,repeat:u=[1,1],offsets:p=[],width:c,height:s}){const a=(0,e.default)(n);let f=a.texture({width:Math.round(c/u[0]),height:Math.round(s/u[1])});const l=()=>a.framebuffer({color:f});let d=(e=>{const r=a.texture(e),t=a.texture(e),o=a.framebuffer({color:r}),n=a.framebuffer({color:t});let i=0;return()=>++i%2==0?o({color:r}):n({color:t})})({width:c,height:s});const g=a.buffer([[-1,-1],[1,-1],[1,1],[-1,-1],[1,1],[-1,1]]),v=a({frag:o,vert:r.default.replace("#define GLSLIFY 1",""),uniforms:{screenSize:a.prop("screenSize"),cameraPosition:a.prop("cameraPosition"),cameraDirection:a.prop("cameraDirection"),offset:a.prop("offset"),repeat:a.prop("repeat"),scrollX:a.prop("scrollX"),scrollY:a.prop("scrollY")},attributes:{position:g},count:6}),b=a({vert:r.default.replace("#define GLSLIFY 1\n",""),frag:"\n            precision highp float;\n            uniform sampler2D inputTexture;\n            varying vec2 uv;\n    \n            void main () {\n              vec4 color = texture2D(inputTexture, uv * 0.5 + 0.5);\n            //   vec4 color = vec4(uv.x, uv.y, 0, 1);\n              gl_FragColor = color;\n            }\n        ",uniforms:{inputTexture:a.prop("texture")},attributes:{position:g},count:6}),m=a({vert:r.default.replace("#define GLSLIFY 1\n",""),frag:t.default.replace("#define GLSLIFY 1\n",""),uniforms:{inputSample:a.prop("sample"),previous:a.prop("previous"),repeat:a.prop("repeat"),offset:a.prop("offset"),screenSize:a.prop("screenSize")},attributes:{position:g},count:6});return{regl:a,drawToCanvas:b,generateRenderSteps:function*(e){const r=l();r.use(()=>{v(i({screenSize:[c/u[0],s/u[1]],offset:[0,0],repeat:u},e)),console.log("hier moet het eigenlijk 255 zijn",a.read())}),yield r;let t=d();t.use(()=>{b({texture:r})});const o=(r,t)=>{const o=l();o.use(()=>{v(i({screenSize:[c/u[0],s/u[1]],offset:t,repeat:u},e))});const n=d();return n.use(()=>{m({sample:o,previous:r,repeat:u,offset:t,screenSize:[c,s]})}),n};for(let n of p)t=o(t,n),yield t;return t}}}var c=p;exports.default=c;
},{"./pass-through-vert.glsl":"Tb0D","./upsample.glsl":"GMqR"}],"redA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var e=n(require("./mandelbulb.glsl")),r=n(require("./renderer.js")),t=n(require("gl"));function n(e){return e&&e.__esModule?e:{default:e}}const l=(n=1e3,l=1e3)=>{const o=(0,t.default)(n,l,{preserveDrawingBuffer:!0}),a=(0,r.default)({frag:e.default.replace("#define GLSLIFY 1",""),reglContext:o,repeat:[1,1],offsets:[],width:n,height:l}),s=e=>{const r=a.generateRenderSteps(e);let t=r.next();for(;!t.done;)t=r.next();const n=t.value;return a.drawToCanvas({texture:n}),console.log(a.regl.read()),a.regl.read()};return{renderFrame:s,renderFrames:(e,r=60)=>{const t=e[0],n=(e[e.length-1].time-t.time)/1e3,l=Math.ceil(n/(1e3/r)),o=[];for(let a=0;a<l;a++){const n=a*(1e3/r),l=e.findIndex(e=>e.time-t.time>=n);if(-1===l)break;console.log(l);const d=e[l];o.push(s(d.state))}return o}}};var o=l;exports.default=o;
},{"./mandelbulb.glsl":"PqeC","./renderer.js":"QpQU"}],"epB2":[function(require,module,exports) {
"use strict";var e=s(require("../headless.js")),r=s(require("express")),t=s(require("cors")),n=s(require("body-parser")),o=require("node-libpng");function s(e){return e&&e.__esModule?e:{default:e}}function c(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,n)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?c(Object(t),!0).forEach(function(r){a(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}const l=(0,r.default)();l.use((0,t.default)()),l.use(n.default.json());const u=3e3,p=100,f=100,b=(0,e.default)(100,100),d=e=>e.map(e=>i(i({},e),{},{state:i(i({},e.state),{},{cameraDirection:Object.values(e.state.cameraDirection)})}));l.get("/",(e,r)=>{r.send("Hello World!")}),l.post("/render",async(e,r)=>{var t;const n=b.renderFrames(d(null===(t=e.body)||void 0===t?void 0:t.frames)),s=Buffer.from(n[n.length-1]);console.log(s),await(0,o.writePngFile)("image.png",s,{width:100,height:100}),r.send("Great success!")}),l.listen(3e3,()=>{console.log("Example app listening at http://localhost:3000")});
},{"../headless.js":"redA"}]},{},["epB2"], null)
//# sourceMappingURL=/main.js.map